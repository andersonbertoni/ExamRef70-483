using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Skill1_5_ImplementExceptionHandling
{
    class Program
    {
        private enum Items
        {
            Sair = -1,
            None = 0,
            TryCatch = 1,
            ExceptionObject = 2,
            ExceptionsTypes = 3,
            FinallyBlock = 4
        }

        static void Main(string[] args)
        {
            bool run = true;

            while (run)
            {
                Items item = Items.None;

                int i = -1;

                while (i < 0)
                {
                    Console.WriteLine();
                    Console.WriteLine("--------------------------");
                    Console.WriteLine("Exam Ref 70-483 - Examples");
                    Console.WriteLine("--------------------------");

                    foreach (var j in Enum.GetValues(typeof(Items)))
                    {
                        if (Convert.ToInt32(j) > 0)
                        {
                            Console.WriteLine("{0} - {1};", Convert.ToInt32(Enum.Parse(typeof(Items), j.ToString())),
                                                            Enum.GetName(typeof(Items), j));
                        }
                    }

                    Console.WriteLine("S - Sair");

                    string valor = Console.ReadLine().ToLower();

                    if (valor == "s")
                    {
                        item = Items.Sair;
                        i = 99;
                    }
                    else if (int.TryParse(valor, out i))
                    {
                        item = (Items)Enum.Parse(typeof(Items), valor);
                    }
                }

                switch (item)
                {
                    case Items.TryCatch:
                        TryCatchExample();
                        break;
                    case Items.ExceptionObject:
                        ExceptionObjectExample();
                        break;
                    case Items.ExceptionsTypes:
                        ExceptionsTypesExample();
                        break;
                    case Items.FinallyBlock:
                        FinallyBlockExample();
                        break;
                    case Items.Sair:
                        run = false;
                        break;
                }

                if (run)
                {
                    Console.WriteLine("Finished processing. Press a key to end.");
                    Console.ReadKey();
                }
            }
        }

        #region Try Catch Example Method

        private static void TryCatchExample()
        {
            try
            {
                Console.Write("Enter an integer: ");
                string numberText = Console.ReadLine();

                int result;
                result = int.Parse(numberText);
                Console.WriteLine("You entered: {0}", result);
            }
            catch
            {
                Console.WriteLine("Invalid number entered");
            }
        }

        #endregion

        #region Exception Object Example Method

        private static void ExceptionObjectExample()
        {
            try
            {
                Console.Write("Enter an integer: ");
                string numberText = Console.ReadLine();

                int result;
                result = int.Parse(numberText);

                Console.WriteLine("You entered: {0}", result);
            }
            /* The catch keyword is followed by the type of the exception to be caught and the name
             * to be used to refer to the exception object during the exception handler */
            catch (Exception ex)
            {
                /* The value of ex is set to refer to the exception that is generated by the Parse 
                 * method if it fails. */

                /* The first line of the output gives the error message */
                Console.WriteLine("Message: {0}", ex.Message);
                /* The StackTrace gives the position in the program at which the error occurred */
                Console.WriteLine("StackTrace: {0}", ex.StackTrace);
                /* The HelpLink property can be set to give further information about the exception. */
                Console.WriteLine("HelpLink: {0}", ex.HelpLink);
                /* The TargetSite property gives the name of the method that causes the exception */
                Console.WriteLine("TargetSite: {0}", ex.TargetSite);
                /* The Source property gives the name of the application that caused the error, 
                 * or the name of the assembly if the application name has not been set */
                Console.WriteLine("Source: {0}", ex.Source);
            }
        }

        #endregion

        #region Exception Types Example Method

        private static void ExceptionsTypesExample()
        {
            try
            {
                Console.Write("Enter an integer: ");
                string numberText = Console.ReadLine();
                int result;
                result = int.Parse(numberText);
                Console.WriteLine("You entered: {0}", result);
                int sum = 1 / result;
                Console.WriteLine("Sum is: {0}", sum);
            }
            /* The user did not enter a valid number */
            catch (NotFiniteNumberException nx)
            {
                Console.WriteLine("Invalid number");
            }
            /* The user entered the value 0, which will cause a divide by zero exception */
            /* Note that not all arithmetic errors will throw an exception at this point 
             * in the code; if the same division is performed using the floating point or
             * double precision type, the result will be evaluated as "infinity" (8) */
            catch (DivideByZeroException zx)
            {
                Console.WriteLine("Divide by zero");
            }
            /* There is a third catch element, which will catch any other exceptions that might
             * be thrown by this code.
             * The order of the catch element is important. If the first catch element caught 
             * the Exception type the compiler would produce the error "A previous catch clause 
             * already catches all exceptions of this or of a super type ('Exception')". 
             * You must put the most abstract exception type last in the sequence. */
            catch (Exception ex)
            {
                Console.WriteLine("Unexpected exception");
            }
        }

        #endregion

        #region Finally Block Example Method

        private static void FinallyBlockExample()
        {
            try
            {
                Console.Write("Enter an integer: ");
                string numberText = Console.ReadLine();
                int result;
                result = int.Parse(numberText);
                Console.WriteLine("You entered: {0}", result);
                int sum = 1 / result;
                Console.WriteLine("Sum is: {0}", sum);
            }            
            catch (NotFiniteNumberException nx)
            {
                Console.WriteLine("Invalid number");
            }
            catch (DivideByZeroException zx)
            {
                Console.WriteLine("Divide by zero");
            }
            catch (Exception ex)
            {
                Console.WriteLine("Unexpected exception");
            }
            /* The finally element identifies code that will be executed irrespective 
             * of whatever happens in the try construction.
             * Note that code in this block is guaranteed to run irrespective of what 
             * happens during the try construction. This includes situations where the
             * code in the construction returns to a calling method or code in the 
             * exception handlers cause other exceptions to be thrown. The finally
             * block is where a program can release any resources that it may be using.
             * The only situation in which a finally block will not be executed are:
             *  - If preceding code (in either the try block or an exception handler)
             *  enters an infinite loop;
             *  - If the programmer uses the Environment.FailFast method in the code
             *  protected by the try construction to explicitly request that any 
             *  finally elements are ignored. */
            finally
            {
                Console.WriteLine("Thanks for using my program.");
            }
        }

        #endregion
    }
}
